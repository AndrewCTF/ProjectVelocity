# Velocity Native Surface Hardening Report

_Date:_ 2025-09-30

## Overview

While extending the C ABI for Velocity, we staged a short offensive review to identify how
attackers might subvert the new handler wiring or the existing handshake flow.  The goal
was to surface practical exploit chains, then land first-line mitigations directly in the
native layer so that downstream integrators do not inherit the typical weaknesses of
HTTP/HTTPS server shims.  This document enumerates the attempted exploits and the defenses
now embedded in the code.

## Exploit 1 — Handler hijack & stuck loops

**Attack idea.** A malicious or buggy consumer could install a handler that never returns,
causing the async server loop to hang and preventing tear-down.  Without a reliable
shutdown primitive, the process would require SIGKILL, resulting in leaked sockets and
unfinished telemetry.

**Defense.** `pqq_stop_server` now aborts the per-port runtime task and drains it on the
shared Tokio runtime before releasing the map entry.  Even if a handler wedges the
request-serving future, the orchestrator can deliver a shutdown signal followed by an
abort.  For defensive depth we surface tracing signals (`shutdown signal received`) so
operators can audit for misuse.

## Exploit 2 — Memory starvation via oversized payloads

**Attack idea.** Absent framing rules, an HTTP-style client could stream arbitrarily large
bodies to exhaust server memory or native caller buffers.

**Defense.** All native-issued application payloads now flow through a strict
`MAX_REQUEST_SIZE` gate (64 KiB by default).  Oversized messages are rejected with a
structured error (`request too large`), preventing native consumers from accidentally
relaying unbounded HTTP content and keeping allocator pressure predictable.

## Exploit 3 — Callback response poisoning

**Attack idea.** A hostile handler could return pointers to stack memory or leave the
response buffer empty, causing use-after-free or undefined behavior when the Rust side
tries to encrypt the payload.

**Defense.** We introduced the `PqqOwnedSlice` container that requires handlers to either
return a well-defined slice (with an optional release hook) or nothing.  All outbound
buffers are copied into an owned `Vec<u8>` on the Rust side before encryption, and null
pointers with non-zero lengths are rejected.  Any callback error is converted into a
sanitized diagnostic frame so the attacker never smuggles arbitrary headers or malformed
ciphertext into the transport.

## Exploit 4 — Downgrade-through-handler fallback

**Attack idea.** Because the original stub always returned an HTTP/1.1 string, a client
could force the stack back into HTTP semantics by injecting method tokens that the default
handler echoed verbatim.  That reintroduced classical HTTP parsing bugs and confused
reverse proxies watching the port.

**Defense.** Velocity’s native request path is now protocol-neutral.  The helper client
sends JSON envelopes (`{"method": ..., "target": ..., "body": ...}`) rather than HTTP
fragments, and the default handler simply echoes raw frames.  Consumers must opt into
HTTP semantics explicitly via a custom handler, eliminating hidden HTTP fallbacks.

## Exploit 5 — Persistent handler reconfiguration

**Attack idea.** Without a registry, integrators had to restart the server to install
security filters or to replace a compromised handler.  Attackers could exploit this lag
to keep malicious behavior live.

**Defense.** The new `pqq_set_handler` and `pqq_clear_handler` APIs allow live swapping of
callbacks on a per-port basis.  Updates are synchronized through a mutex so that in-flight
requests see either the old or the new handler, never a torn pointer.  Operators can now
atomically roll mitigations without reopening sockets or leaking state.

## Exploit 6 — Orphaned ports after crash

**Attack idea.** If the runtime task panicked, the old implementation left no telemetry and
the port entry remained in the map, blocking restarts.

**Defense.** Every task termination path now logs to the `pqq_native::server` target.  When
a task completes naturally or after an abort, the entry is evicted and the join handle is
awaited so the OS releases the socket immediately.  Restart attempts can therefore succeed
without manual cleanup.

## Additional observations

* Handler failures are surfaced as deterministic JSON diagnostics.  This avoids leaking
  raw panic strings across the FFI boundary and gives instrumentation a stable schema.
* The handshake JSON handed to callbacks is serialized once and guaranteed to be valid
  UTF-8; null bytes are rejected to harden downstream C code that expects C strings.
* The default handler (when no callback is registered) is now an echo service.  This
  removes the silent HTTP dependency and allows binary fuzzing directly against Velocity
  frames.

## Next steps

* Consider per-peer handshake rate limiting in `pqq-core` to mitigate UDP spray attacks.
* Expose a telemetry hook in the native crate so operators can feed diagnostic events into
  SIEM pipelines without custom tracing subscribers.
* Expand the fuzz harness to include C callbacks that return adversarial buffers, ensuring
  the `PqqOwnedSlice` guardrails remain correct under sanitizer builds.

With these changes the native bridge better reflects Velocity’s design goals: no hidden
HTTP fallbacks, deterministic teardown, and sane memory ownership across the FFI surface.
```